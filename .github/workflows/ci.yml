name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  shell-lint:
    name: Bash lint & syntax check
    runs-on: ubuntu-latest
    steps:
      # Do NOT automatically fail the checkout step if submodules use SSH and are not accessible
      # Instead we'll attempt to fetch submodules later and continue if they cannot be fetched.
      - uses: actions/checkout@v4
        with:
          lfs: true
          # avoid automatic failure from actions/checkout when submodule fetch needs SSH
          submodules: false
      - name: Install shellcheck
        run: |
          sudo apt-get update
          sudo apt-get install -y shellcheck
      - name: Bash syntax check
        run: |
          for f in ./scripts/*.sh; do bash -n "$f"; done
      - name: Check executable bit on shebang files
        run: |
          set -e
          fail=0
          files=$(git ls-files || true)
          if [ -n "$files" ]; then
            for f in $files; do
              if [ -f "$f" ]; then
                if head -n1 "$f" | grep -q '^#!'; then
                  mode=$(git ls-files --stage "$f" | awk '{print $1}')
                  if [ "$mode" != "100755" ]; then
                    echo "$f has shebang but is not executable in index (mode: $mode). Run: git update-index --chmod=+x $f"
                    fail=1
                  fi
                fi
              fi
            done
          fi
          if [ "$fail" -eq 1 ]; then exit 1; fi
      - name: Run shellcheck
        run: |
          for f in ./scripts/*.sh; do shellcheck "$f" || true; done

  powershell-lint:
    name: PowerShell lint
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
          submodules: false
      - name: Install PSScriptAnalyzer
        shell: pwsh
        run: |
          Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser
      - name: Analyze PowerShell scripts
        shell: pwsh
        run: |
          Invoke-ScriptAnalyzer -Path scripts\*.ps1 -Recurse

  lfs-and-submodule-check:
    name: LFS & submodules
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
          submodules: false
      - name: Detect submodules defined in .gitmodules (no network access)
        run: |
          # We intentionally DO NOT try to fetch or update submodules from CI.
          # Some submodules are private and accessible only via the maintainer's SSH key.
          # Instead we check that the .gitmodules file exists and contains submodule entries.
          if [ -f .gitmodules ]; then
            echo ".gitmodules found:"; cat .gitmodules
            # List submodule paths and urls
            git config -f .gitmodules --get-regexp '^submodule\..*\.path' || true
            git config -f .gitmodules --get-regexp '^submodule\..*\.url' || true
            COUNT=$(git config -f .gitmodules --get-regexp '^submodule\..*\.path' | wc -l || true)
            if [ "$COUNT" -gt 0 ]; then
              echo "SUBMODULES_PRESENT=true" >> $GITHUB_ENV
            else
              echo "SUBMODULES_PRESENT=false" >> $GITHUB_ENV
            fi
          else
            echo ".gitmodules not present"
            echo "SUBMODULES_PRESENT=false" >> $GITHUB_ENV
          fi
      - name: Validate submodules
        if: env.SUBMODULES_PRESENT == 'true'
        run: |
          git submodule status --recursive
      - name: Skip submodule validation (not available)
        if: env.SUBMODULES_PRESENT == 'false'
        run: |
          echo "Submodules not available in this runner (probably SSH-only URLs). Skipping validation."
      - name: Check LFS tracked assets
        run: |
          git lfs ls-files || true
      - name: Check .gitattributes includes assets/**
        run: |
          grep -E '^assets/\*\* filter=lfs' .gitattributes

  install-test:
    name: Verify modules with install.sh
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          lfs: true
          submodules: false
      - name: Install tools (git-lfs)
        run: |
          sudo apt-get update
          sudo apt-get install -y git-lfs || true
      - name: Verify installers & mappings
        run: |
          set -e
          TMP=$(mktemp -d)
          echo "Testing installer against temp target: $TMP"
          chmod +x ./.github/scripts/test-install-mappings.sh
          ./.github/scripts/test-install-mappings.sh

      - name: Check for top-level files in modules that could pollute $HOME
        run: |
          set -e
          cd modules
          FAIL=0
          # Build ALLOWED regex from install-mappings.yml if present (keys before ':'), otherwise fallback
          ALLOWED=''
          if [ -f ../install-mappings.yml ]; then
            keys=$(sed -n 's/^[[:space:]]*//;s/#.*//;s/:.*$//;s/|.*$//p' ../install-mappings.yml | tr '\n' '|' | sed 's/|$//') || true
            if [ -n "$keys" ]; then
              # create regex like ^key1$|^key2$|^\.dotfiles
              # escape keys safely (basic)
              esc=$(echo "$keys" | sed -E 's/([^a-zA-Z0-9_\-\.])/\\\\\\1/g') || true
              ALLOWED="^$(echo "$esc" | sed 's/|/\$|^/g')$|^\\..+"
            fi
          fi
          if [ -z "$ALLOWED" ]; then
            # default to only allowing dotfiles in absence of explicit mappings
            ALLOWED='^\..+'
          fi
          for m in */ ; do
            m=$(basename "$m")
            # find files in module root (not dotfiles) that are not in our allowed list
            while IFS= read -r -d $'\0' f; do
              fname=$(basename "$f")
              if [[ ! "$fname" =~ $ALLOWED ]] && [[ ! "$fname" =~ ^\..+ ]]; then
                echo "ERROR: El módulo $m contiene un archivo en la raíz que puede instalarse en \$HOME y no está declarado en install-mappings.yml: $fname" >&2
                echo "Ruta conflictiva: $m/$fname" >&2
                FAIL=1
              fi
            done < <(find "$m" -maxdepth 1 -type f -print0 || true)
          done
          if [ "$FAIL" -eq 1 ]; then
            echo "Se detectaron archivos en la raíz de módulos que podrían contaminar \$HOME. Agrega un mapeo en install-mappings.yml o renombra/cambia el archivo raíz a un dotfile." >&2
            exit 1
          fi
      - name: Enforce mapping coverage for module root files
        run: |
          set -e
          chmod +x ./.github/scripts/check-mappings.sh
          ./.github/scripts/check-mappings.sh
      - name: Run install.sh against TARGET and verify declared mappings create symlinks
        run: |
          set -euo pipefail
          chmod +x ./.github/scripts/test-install-mappings.sh
          ./.github/scripts/test-install-mappings.sh
      - name: Cleanup
        run: |
          echo "Removing temp"; rm -rf "$TMP" || true
